## map

Go语言中的map是一种无序的键值对集合，用于存储和快速查找数据。其底层实现基于哈希表（Hash Table），并采用链表法（Linked List）解决哈希冲突。

**哈希表**

哈希表是一个由多个桶（Bucket）组成的数组，每个桶用于存储键值对。哈希函数（Hash Function）将键映射到某个桶中，从而实现快速查找。

Go语言的map使用FNV哈希函数（Fast Non-Verifiable Hash Function）将键转换为哈希值。哈希值用于计算键在桶数组中的索引位置。

**链表法**

当多个键映射到同一个桶时，就发生了哈希冲突。为了解决哈希冲突，Go语言的map采用链表法。即，在冲突的桶中维护一个链表，将具有相同哈希值的键值对串联起来。

**扩容**

随着键值对数量的增加，哈希表的负载因子（Load Factor）也会随之增大。负载因子是指已使用的桶的数量与桶总数的比率。当负载因子超过某个阈值时，map会进行扩容。

Go语言的map采用增量扩容（Incremental Rehashing）策略。即，在插入或删除键值对时，如果发现负载因子超过阈值，则会进行部分桶的搬迁。这样可以避免一次性搬迁所有桶带来的性能开销。

**并发安全**

Go语言的map默认是非并发安全的。这意味着，如果多个线程同时对同一个map进行读写操作，则可能发生数据竞争（Data Race）。

为了解决并发安全问题，Go语言提供了sync.Map类型。sync.Map内部使用了读写锁（Read-Write Lock）来保护map的并发安全。


> hash冲突常用*线性探测*或者*拉链法*
> 开放定址（线性探测）和拉链的优缺点
>
>    - 拉链法比线性探测处理简单
>    - 线性探测查找是会被拉链法会更消耗时间
>    - 线性探测会更加容易导致扩容，而拉链不会
>    - 拉链存储了指针，所以空间上会比线性探测占用多一点
>    - 拉链是动态申请存储空间的，所以更适合链长不确定的


### map的底层结构

* dlv查看底层结构 

因为编译器对map make有优化, 对以下代码执行dlv debug main.go
```go
m := make(map[int64]struct{}, 100)
// call $runtime.makemap  汇编调用函数

m2 := map[int64]struct{}{
		1: {},
		2: {},
		3: {},
		4: {},
}
// call $runtime.mapassign_fast64 汇编调用函数
```

不管是哪个函数最终都会返回一个结构:
```go
type hmap struct {
    count     int // 元素个数
    flags     uint8
    B         uint8  // 桶的个数，总是2的幂次方
    noverflow uint16 // 溢出桶的个数
    hash0    uint32 // hash种子

    buckets    unsafe.Pointer // 桶数组，大小为2的幂次方
    oldbuckets unsafe.Pointer // 旧桶数组
    nevacuate uintptr // evacuation 进度计数器（已疏散少于此的桶）

    extra *mapextra // optional fields
}
```









### map的特殊语法

map的特殊语法叫特权语法, 例如访问一个map的元素它可以能返回一个值，它有时候又能返回两个值. 实际上这是Go语言里的语法糖, 就是我给你提供了一些写法，但实际上它底层对应了一个特殊的实现，比如说我返回一个值，它其实被翻译成了runtime.mapaccess1。如果用到了常见的comm-ok的语法，它就被翻译成了runtime.mapaccess2.这个翻译过程是编译器帮你做的。编译器判断这个赋值语句左边有几个值，如果有一个那我就翻译成这个函数,如果有两个那我就翻译成另外一个函数,是非常简单的if else的逻辑。

创建map可以看这里这个make, 看起来像一个内置的函数，但它可以传两个参数，或者只传一个参数，也是我们在正常写用户代码里实现不了的功能，对吧？也是编译器帮你翻译的，它最终会给你翻译出一个makeXXmap之类的函数, 在翻译的时候会判断说你当前的这个对象是在栈上还是在堆上创建的, 根据这个类型会有一堆类似的make函数.因为Go没有泛型，所以在做一些map的读或者写操作时，它具体会对应到一堆函数里面去.不同的数据类型、不同的数据大小都会对应不同的map方法.

这就是语法糖最终底层的函数, 有一大堆、各种乱七八糟的衍生. 官方其实自己也非常的头疼，像这种函数有同一个函数，它所有的逻辑代码可能都差不多，每两个函数之间可能也就那么三四行有区别，这种场景其实是非常适合用泛型来写的。但是因为Go以前没有泛型，所以就搞了这么一大堆的函数. map曾经被Uber的人发现一个bug，比如说它是access里面有bug，然后官方就需要把这所有类似的4个函数都改一遍，官方的人在自己提cl的时候，写了一个注释说这个如果说我们有泛型的话，这也就只需要改一遍就好了。

### reference

- [go里面的哈希表](https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/)