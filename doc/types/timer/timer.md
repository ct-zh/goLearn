## timer

timer基本结构为一个小顶四叉堆, 离当前时间最近的时间肯定是在堆顶的. 

最老的版本timer全局只有一个四叉堆，他会针对这个四叉堆专门起一个goroutine: 逻辑是运行一个for循环，会不断的去检查你的规定元素是不是已经到期了，如果到期他就会触发，在触发的同时会逐渐的调整你的堆，直到把所有需要触发的timer都触发完毕为止，继续去休眠，这就是这个time lock的简单逻辑. 

这种单一的四叉堆有什么问题呢? 就是所有的goroutine在执行他们相关的操作的时候，都需要去抢占操作这个堆的全局锁。而这个锁是写锁，如果说我的并发量很高，那就会导致我的程序整体的吞吐量下降，这个全局锁对于任何的程序来说都都是性能伤害比较大的.

早期Go语言timer堆的实现，导致了Go语言在多核的处理器上性能不佳。有人在给他们贴了issue，虽然现在看Go语言内部的数据结构，很多已经实现非常复杂了，但是它其实都是从非常简单的逻辑、简单的结构一步一步迭代过来的.比如说你看四叉堆其实就非常的简单，当时的代码实现也非常的少，不断的有人提出来单个的四叉堆和一把全局大锁的性能是有问题的之后，他们的官方团队就需要去做这个优化，他们的思路是什么呢？

就是我既然一个堆和一把锁是有性能问题的，那么我就要尝试把单个的四叉堆变成多个四叉堆，尽量把它的并发性能提升，也就是降低我的锁的力度。(有同学说是分片锁, 它确实是一个分片锁) 然后从单个四叉堆后来变成了一个什么结构呢？就是变成了多个4叉堆，这个地方是完全写死的，最多会有64个四叉堆，但是它一般不会有这么多。而是根据需要, 比如说我的gomaxprocs等于8, 说明我的P结构是有8个，每1个P它在执行那调度循环的时候会绑定1个线程，线程上正在执行G, 也就是time.sleep或者time.after的时候，我需要把这个timer插入到我的四叉堆里面，它和以前的逻辑就不一样了。

现在用当前的g绑定的M，然后找到它的对应的这个P，按照它的这个pID找到timers数组里面的对应的timer元素，也就是一个4叉堆的结构, 在这种情况下，在每一个P下面执行的这些线程，其实都会找到自己对应的一个四叉堆，也就是它要加锁，那就只是在操作自己的这个元素的时候需要加锁, 相当于把这个锁的力度变小了。

这个锁就从原来1个全局锁变成了64把锁, 当然它不会创建这么多，如果我的P只有8个的话，那其实这个timers数组也就只会有8个元素，每一个元素都和以前的一个四叉堆都完全一样的，前面提到了说会有一个单独的gorooutine一直检查堆里的元素是不是已经到期了，现在他的逻辑也没有什么大变化，只是goroutine变多了，原来有一个那现在其实我就是每一个四叉堆都对应了1个检查的goroutine，我现在有8那就是有8个如果说，我超过了64，那就是有64个。就是一个非常简单的分拆的操作，到这里还是实现比较简单的，但是在社区里面又有人提出了一些问题，他说我们如果说有很多个goroutine在执行检查，如果是CPU密集型计算任务, 会导致他们自己的goroutine被延迟唤醒，(这方面的issuc有好几个)，然后这之后官方又做了一些改进，从这个版本往后这个他们实现就极其的复杂了.

在1.14之后，Go团队把timer数组直接干掉了，四叉堆直接变成了和P绑定的情况，然后在P里面新建了一个timer，对整个的维护操作相当于没有了原来的这个单独执行for循环检查的proc函数，也就是说额外的goroutine都没有了.既然没有了这个东西，但是这个四叉堆还存在，那现在他检查一定是要移动到别的地方去，他移动到什么地方去了? 就是移动到调度循环里面的schedule过程。

但是锁其实还是有的, 因为它P和P之间有时候会从别的地方去拿别人的timer过来执行。就是有一些互相之间的操作，所以还是有锁的。在这个版本里面，那个你们如果要看代码就就是看这个check他们在什么地方执行了，其实非常的非常的恶心，整个的timer也不像以前的那么简单直接了，因为要考虑说现在我现在改成这样以后，关键的一些流程变成了去schedule函数里面执行。

这个schedule是调度里的核心流程，我不能执行特别重的操作，所以他在里面就要考虑说有一些可能特别重的操作就要把它做一些分拆，变成比如说我本来原来是删除、调整堆，这个对于我的调度过程来说，可能就是一个非常重要的操作。那我可能现在就不是把它一次清理掉，而是先把它改一个状态，在之后的什么时机再去触发清理，所以整个的流程变得非常非常的复杂。

他简单的调整有这么几方面吧，第一方面是把他们的他们堆和GMP里面的P结构做了个绑定，原来是没有这个绑定关系的，它只是在一个全局数组里面，然后这个数组是按照P的ID去哈希，现在他把那个原来time.proc这个单独的检查堆顶的goroutine也去掉了.

然后在那个对于timer到期的检查，变成了专门的一个check timers函数里进行。这个流程就是转到了schedule流程里，然后在那上面里增加了大量的状态

除了这些以外，还给这个他们的执行流程增加了工作介质，这个和goroutine的works steeling是相关的，看代码可以看一下，两个其实是在一块，只是我如果一开始偷不到go routine的话，在执行了几个round之后，他就会做一些timer相关的偷取工作，

除了这些还在那整体的后台监控线程里面做了一个兜底。有一些情况下可能是因为我线程不够了，所以导致一些timer没有被执行，所以还要需要额外的启动新线程去执行timer。

这就是1.14的变化，主要是因为之前的设计导致了一些他们被执行不及时的问题。

为什么没有和什么工业界保持一致?这个他们也是一个工业界的实现，有一些软件它就是用这种堆去实现他们，然后另外一些软件可能选择了时间轮，我们在线上系统里其实还经常会见到他们这个流程

比如timer里面的函数执行的CPU消耗比较高，比如说我们之前在蚂蚁的场景，他们是看到time相关的函数就占了大概7%~8%的CPU，然后这时候大家就会觉得这个消耗实在太高了，想把它尽量减少一些，也有这么几个思路，有些人就是想到了其他软件里常见的时间轮，时间轮是怎么做优化的呢 ? 它其实是把那个time触发的粒度变粗了，也就是我们平常做一些超时，我们不需要什么纳秒啊或者微秒级的时间力度，所以我们想办法，比如说把它变成10毫秒级，然后通过减少它的粒度，然后降低检查的频率，从而减少他们相关的函数的CPU消耗。


- 单个四叉堆timer的loop check时间间隔是多少?
    - 算堆顶的到期时间, 然后sleep
    - 为啥是四叉堆? 空间局部性好一些, N叉堆通常是2的N次方

- timeproc会因goroutine的公平性而延迟执行吗? 会


#### Timer1.14:
- 调整
    - Timer heap与GMP中的P绑定;
    - 去除唤醒goroutine - timerproc
- 检查
    - 检查timer到期在特殊函数checkTimers中进行
    - 检查timer操作移至调度循环中进行
- 工作窃取
    - 在work stealing中会从其他P偷走timer
- 兜底
    - runtime.sysmon中会为timer未被触发timeSleepUntil兜底, 启动新线程.
