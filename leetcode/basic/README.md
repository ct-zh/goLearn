# 算法基础

## 1. 最常见的问题：数组

### 写出正确的程序
根据二分查找法来进行分析：
1. **严格限定变量的实际意义**。如定义数组边界的两个变量l与r，如果设定为l=0,r=n-1，则查找区间是`[l...r]`这个闭区间内。如果l=-1，r=n，则查找区间就变成了`(l...r)`这个开区间内。

2. 注意边界问题。
3. 注意题目中会不会有溢出的问题。
4. 小数据量调试：单元测试
5. 大数据量测试：性能测试

### 开始解决算法问题：数组
**面对问题不要想当然**
注意如果题干没有提及，那么可以询问面试官题目的具体要求，例如一道题目要求在数组中删除特定的元素，问题一般有：
- 如何定义删除？从数组中去除？还是放在数组的末尾？
- 剩余元素的排列是否要保证原有的相对顺序？
- 是否有空间复杂度的要求？O(1)

如果是查找题，则问题一般有：
- 如果没有解？ （通常会保证有解，或者返回0）
- 如果有多个解？ （返回任意解，或者返回最大/小解，返回所有解，那所有解的顺序是怎么样的？）

如果是字符串的问题，一般有：
- 空字符串如何看?例如回文题，空字符串是否被看为回文
- 字符的定义? 只有数字+字母，还是所有ascii码都取
- 大小写的问题?
- 子串的定义？例如"pwwkew"，"wke"是一个子串，那"pwke"是不是子串？（这个通常称为子序列）

如果是数组问题：
- 什么是子数组？有的题目会要求子数组是连续的

**在实现完代码后，一定要想，我能不能做的更好？**

**但是注意,通常算法是无法兼顾时间复杂度与空间复杂度的**

#### 单元测试的写法(自己逐步归纳)
##### 测试用例
1. 非法数据
2. 边际数据
3. 完全不符合条件的数据
4. 空数据
5. 负数/小数
6. 长度很大的数据；


## 2. 查找问题
### 实战
一般有两类查找问题：
1. 查找有无，元素a是否存在？一般用set集合；
2. 查找对应关系（键值对应）某个元素a出现了几次？一般用map字典

对于查找问题，可以通过辅助的数据结构来进行解答。除了上面的set与map两种结构，还可以实现一些更加底层的结构，下面做一下几个结构的时间复杂度比较
1. 普通数组：插入O(1),查找O(n),删除O(n)
2. 顺序数组：插入O(n),查找O(logn)(二分搜索),删除O(n)
3. 二分搜索树（平衡）：插入O(logn),查找O(logn),删除O(logn)
4. 哈希表：插入O(1),查找O(1),删除O(1)。但是哈希表失去了数据的顺序性（unordered）。

通常问题使用哈希表就可以解决了，如果对顺序有要求的可以考虑使用平衡二叉树

#### 时间复杂度的问题 
我们在解答问题时会经常使用辅助的数据结构。所以如果计算时间复杂度，还要看这些结构操作的时间复杂度。例如一次循环，每次循环往二分搜索树中查找数据，那么时间复杂度应该是循环的时间复杂度O(n)加上二分搜索树查找数据的时间复杂度O(logn),也就是O(nlogn)

#### 数据规模
1. 题目中有时直接给了数据规模的取值范围,例如454题,直接说了数组的元素个数在`[0...500]`这个区间内;根据这个数据规模的取值范围,就能推测出大概需要一个什么时间复杂度的算法.

    例如454需要在四个数组中做查找,暴力解法的时间复杂度为O(n^4),即500^4;即使将最后一个数组放入查找表,也需要500^3次循环.所以这里应该是设计一个至少是n^2级别的算法.即需要将两个数组的元素放入查找表.

2. 如果题目中出现了除法、开根号等操作,需要考虑到计算结果的数据类型从int转变为float; 同理如果出现乘法,也要考虑到int转变成int64的可能.


## 3. 链表问题
### 实战注意问题
1. 通常链表题目是不能改变链表节点的值的,而是对节点的next/pre进行操作;

2. 一定要判断当前链表是否等于nil,尤其存在删除操作时.另外go语言里定义了链表结构,delete操作是不能写成链表结构的地址类型的成员方法的`func (l *ListNode) delete(val int) bool`,因为这里的头节点`l`不是一个变量,如果有删除头节点的操作,但是`l`是不能修改的,这里不会出现报错,而是会导致头节点的重新赋值操作失败!

## 4. 栈、队列、优先队列
### 栈与递归的关系
函数递归是通过栈来实现的

### 队列
队列经常用于广度优先遍历,如:树的层次遍历;无权图的最短路径

### 优先队列
优先队列的底层实现是堆,出队的是权值最高的数据.

## 5. 二叉树与递归
### 递归
递归算法的内容有 : 1. 递归终止条件;2. 递归调用逻辑; 

> 二分搜索树：若左子树不为空，左子树上所有节点都比根节点小；若右子树不为空，右子树上所有节点都比根节点大。
可以知道二叉树的定义天然递归: 1. 递归终止条件: "若左子树/右子树不为空"; 2. 递归调用逻辑: 左子树/右子树所有节点都比根节点小/大


## 6. 回溯
> 递归调用的一个重要特征: 需要返回; 这个流程就是回溯.

1. 回溯法的时间复杂度一般都比较高,回溯法是暴力解法的主要实现手段.
2. 回溯法的流程通常是固定的(见leetcode解题,用回溯法的答案总体框架都是固定的)

回溯法解决:
1. 排列问题
2. 组合问题

回溯法的剪枝:

### 8-7 floodfill算法
在某个初始点开始,进行深度优先遍历

> 回溯法是经典人工智能的基础;


## 7. 动态规划
什么是动态规划?
对于斐波那契数列,有如下实现方式
```go
func fib(n int) int {
    if n == 0 {
        return 0
    }
    if n == 1 {
        return 1
    }
    return fib(n-1) + fib(n-2)
}
```
这个算法的时间复杂度为: `O(2^n)`; n=40的时候运行时间就超过1秒了,而且fib增长速度很快,n比较大的时候就不能返回int了,只能返回int64

画出树状的调用结构,可以发现上面代码有大量的重复计算,例如`fib(5)`,会有`fib(3)`计算两次,`fib(2)`计算三次.可以增加一个缓存`memo`来解决重复计算的问题,这种解决方式叫**记忆化搜索**,代码修改之后变成了`O(n)`
```go
func fib(n int, memo *[]int) int {
    if n == 0 {
        return 0
    }
    if n == 1 {
        return 1
    }

    if (*memo)[n] == -1 {
        (*memo)[n] = fib(n-1) + fib(n-2)
    }

    return (*memo)[n]
}
```

记忆化搜索是自上而下地解决问题; 而动态规划是自下向上的解决问题: 先解决小数据量的问题,再层层递推,解决大数据量下的问题.如下代码,时间复杂度仍然是`O(n)`,但是没有递归调用,而且每个memo只会访问一次:
```go
func fib(int n) {
    memo := make([]int, n+1)

    memo[0] = 0
    memo[1] = 1
    for i := 2;i<=n;i++{
        memo[i] = memo[i-1] + memo[i-1]
    }
    return memo[n]
}
```

动态规划: 将原问题拆解成若干子问题,同时保存子问题的答案,使得每个子问题只求解一次,最终获得原问题的答案.

> dynamic programming (also known as dynamic optimization) is a method for solving a complex problem by breaking it down into a collection of simpler subproblems, solving each of those subproblems just once, and storing their solutions - ideally, using a memory-based data structure.

递归问题 => 重叠子问题 => 记忆化搜索/动态规划

### 发现重叠子问题
最优子结构:通过求子问题的最优解,可以获得原问题的最优解

### 状态的定义与状态转移
考虑偷取`[0...n-1]`范围内的所有房子
偷取0： 问题变成偷取`[2...n-1]`范围内的房子

状态的定义: 考虑偷取`[x...n-1]`范围内的房子

根据对状态的定义，决定状态的转移：
f(0) = max{v(0) + f(2), v(1) + f(3), v(2) + f(4), ...,v(n-3) + f(n-1), v(n-2), v(n-1)} (状态转移方程)

### 0-1背包问题
有一个背包,容量为C.现有n种不同的物品编号为0...n-1,其中每一件物品的重量为w(i),价值为v(i).问可以向这个背包中盛放哪些物品,使得在不超过背包容量的基础上,物品的总价值最大.

暴力解法: 每一件物品都可以放进背包,也可以不放进背包.
O((2^n)*n)

F(n, C)考虑将n个物品放入容量为C的背包,使得价值最大
```
// 情况一,不需要考虑第i件物品,则问题转换为这个式子
// 情况二, 需要考虑第i件物品,则问题转换为此
F(i, c) = max( F(i-1, c),  v(i) + F(i-1, c-w(i))  )
```

```go
// w为每件物品的总重量；v为价值；背包容量为C
// 需要返回物品的最大总价值
func knapsack(w []int, v []int, C int) int {
	wLen := len(w)
	k := Knapsack01{
		memo: make([][]int, wLen),
	}
	for i := 0; i < wLen; i++ {
		k.memo[i] = make([]int, C+1)
		for j := 0; j <= C; j++ {
			k.memo[i][j] = -1
		}
	}
	defer fmt.Println(k.memo)
	return k.bestValue(w, v, wLen-1, C)
}

type Knapsack01 struct {
	memo [][]int // 因为有两个约束条件:物品、剩余容积; 所以memo是一个二维数组,第一个key代表物品,第二个key代表剩余容量. 即memo[i][j] 代表第i个物品放入容量为j的背包时可以得到的最大的价值
}

// 用[0...index]的物品，填充容积为c的背包的最大价值
func (k *Knapsack01) bestValue(w []int, v []int, index int, c int) int {
	// 如果当前已经没有了物品/没有了容量
	if index < 0 || c <= 0 {
		return 0
	}

	if k.memo[index][c] != -1 {
		return k.memo[index][c]
	}

	// 情况1, 无视该物品
	res := k.bestValue(w, v, index-1, c)
	if c >= w[index] { // 如果该物品可以装进背包
		// 情况2，包含该物品
		res2 := k.bestValue(w, v, index-1, c-w[index]) + v[index]
		res = Helper.MaxInt(res, res2)
	}

	k.memo[index][c] = res
	return res
}

func main() {
	w := []int{
		0: 1,
		1: 2,
		2: 3,
	}
	v := []int{
		0: 6,
		1: 10,
		2: 12,
	}

	res := knapsack(w, v, 5)
	fmt.Println(res)
}
```

### 0-1背包问题的优化与变种
对于状态转移方程`F(i, c) = max(F(i-1, c), v(i) + F(i-1, c-w(i)))`第i行元素依赖于i-1行元素.理论上,只需要保持两行元素,空间复杂度变成O(2C) = O(C)

变种: 1. 完全背包问题: 每个物品可以无限使用;2.多重背包问题:么个物品不止一个,有num(i)个;3.多维费用背包问题,要考虑物品的体积与重量;4. 物品之间有排斥/依赖

### 面试中的背包问题

### LIS 问题 Longest Increasing Subsequence
最长上升子序列


### LCS、最短路等等
最长公共子序列Longest Common Subsequence



## 8. 贪心算法

贪心算法与动态规划的关系

贪心选择性质: 在求解一个最优化的问题中,我们使用贪心的方式选择了一组内容之后,不会影响剩下的子问题的求解;

如果探讨一个问题无法使用贪心算法,举反例即可; 如果无法举出反例,如何证明贪心算法的正确性?  => 反证法

> 在算法中用到最多的数学证明方法:1. 数学归纳法;2. 反证法.

例如:(leetcode 435) 给定一组区间,问最多保留多少个区间,可以让这些区间互相不重叠? 贪心算法:按照区间的结尾排序,每次选择结尾最早的,而且和前一个区间不重叠的区间;

某次选择的是`[s(i), f(i)]`;其中f(i)是当前所有选择中结尾最早的

证明: 假设这个选择不是最优的.也就是说,如果这个问题的最优解为k,则这个选择得到的解,最少为k-1. 假设最优解在这一步选择`[s(j), f(j)]`中, f(j)>f(i)(因为f(i)是结尾最早的). 此时,显然可以将`[s(i), f(i)]`替换`[s(j), f(j)]`,而不影响后续区间选择.此时,当我们选择了`[s(i), f(i)]`时,也构成了一个大小为k的解. 但是和之前的假设矛盾. 

贪心算法为A;最优算法为O;发现A完全能替代O,且不影响求出最优解.


## 题目解法思路总结:
1. 数组: 双指针; 对撞指针; 滑动窗口
2. 字符串: 转换为字符串数组/byte数组;
3. 多个数组: 查找表(需要数据顺序性就使用平衡二叉树,不需要就使用哈希表)
4. 链表: 设置虚拟头节点(存在对头节点操作时), 双指针(leetcode19,删除倒数第x个元素);


